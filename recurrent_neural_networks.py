# -*- coding: utf-8 -*-
"""recurrent_neural_networks

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xuIpBsVqU8mhiWOKzWNpC8PBMrsWXwRF

## RNNs (Non-Linear Networks)
"""

import tensorflow as tf
import tensorflow.compat.v1 as tfold
from tensorflow import keras
from tensorflow.keras import models
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Activation, Input, BatchNormalization, LSTM, Lambda
import numpy as np
#from keras_visualizer import visualizer
from tensorflow.keras.utils import plot_model
import matplotlib.pyplot as plt
from math import *
class rnns():

  def __int__(self):
    tfold.disable_eager_execution()
    pass
  def make_many_one_model(self, serial_input_card=3, architecture_per_ss=[("inpk",2), ("ffk",10), ("jnk",1), ("ffk", 1)], activation="sigmoid", hidden_activations="sigmoid", describe_model=True):
    
    M = serial_input_card
    layer_count = 0
    m = architecture_per_ss[0][1]

    
    LAYERS = []
    JN_MARK = []

    for layer_struct in architecture_per_ss:
      layer_count +=1
      
      if layer_struct[0] == "inpk":
        xinpk = Input(shape=(M, m,))

        ffk_index = 1
        jnk_index = 1
        LAYERS.append(xinpk)

      elif layer_struct[0] == "ffk":
        
        if layer_count == len(architecture_per_ss) :
          act = activation
        else:
          act = hidden_activations

        globals()["dl" + str(ffk_index)]= Dense(layer_struct[1], activation=act, name="ff" + str(ffk_index))

        LAYERS.append(globals()["dl" + str(ffk_index)])
        ffk_index += 1
        
        
      
      elif layer_struct[0] == "jnk":
        shape_consider = (1, layer_struct[1])

        globals()["jn" + str(jnk_index)]= Dense(layer_struct[1], activation="relu", name="jn" + str(jnk_index))
        jnsl = Dense(layer_struct[1], activation="relu", name="jnsl" + str(jnk_index))

        LAYERS.append(globals()["jn" + str(jnk_index)])
        JN_MARK.append(layer_count-1)
        jnk_index += 1
        
        
        

    
    hprev = tf.zeros(shape=shape_consider)
    
    xinp = LAYERS[0]
    
    for ss in range(M):
      for la in range(layer_count):
        if la == 0:
          #xinp2 = xinp1[ss]
          globals()[("inp" + str(ss))] = xinp[:, ss, :]#Lambda(self.slice, arguments={'timestamp':ss})(xinp) 
          x = globals()[("inp" + str(ss))]#xinp2
        elif la in JN_MARK:
          hprev = jnsl(hprev) + LAYERS[la](x)
          x = hprev
        else:
          x = LAYERS[la](x)
  

    model = Model(inputs=xinp, outputs=x)
    if describe_model == True:
      print(model.summary())
    return model

    """
    for layer_struct in architecture:
      layer_count +=1
      if layer_struct[0] == "inpk":
        m = layer_struct[1]
        
        for k in range(1, M+1):
          globals()[("inp" + str(k))] = Input(shape=(m,), name="inp"+str(k))
        
        ffk_index = 1
        jnk_index = 1
      elif layer_struct[0] == "ffk":

        if ffk_index == 1:
          xnow = [globals()["inp" + str(i)] for i in range(1, M+1)]
        
        if layer_count == len(architecture) :
          act = activation
        else:
          act = "sigmoid"

        globals()["dl" + str(ffk_index)]= Dense(layer_struct[1], activation=act, name="ff" + str(ffk_index))
        
        for k in range(1, M+1):
          globals()[("x" + str(k))] = globals()["dl" + str(ffk_index)](xnow[k-1])
        
        xnow = [globals()["x" + str(i)] for i in range(1, M+1)]
        ffk_index += 1
        
      
      elif layer_struct[0] == "jnk":
        shape_consider = (1, np.shape(xnow[0])[1])
        
        hprev = tf.zeros(shape=shape_consider, name="jn" + str(jnk_index))
        
        globals()["jn" + str(jnk_index)]= Dense(layer_struct[1], activation="relu", name="jn" + str(jnk_index))

        for k in range(1, M+1):
          globals()["x" + str(k)] = globals()["jn" + str(jnk_index)](hprev) + xnow[k-1]
          hprev = globals()["x" + str(k)]
        
        xnow = [globals()["x" + str(i)] for i in range(1, M+1)]
        jnk_index += 1
        """

a = "end"

"""sin_wave = [sin(x) for x in np.arange(200)]

plt.plot(sin_wave)

X = []
Y = []

seq_len = 50
num_records = len(sin_wave) - seq_len

for i in range(num_records - 50):
    X.append(sin_wave[i:i+seq_len])
    Y.append(sin_wave[i+seq_len])
    
X = np.array(X)
X = np.expand_dims(X, axis=2)

Y = np.array(Y)
Y = np.expand_dims(Y, axis=1)"
"""

#nn1 = rnns()
#model = rnns.make_many_one_model(serial_input_card=50, architecture_per_ss=[('inpk', 1), ('ffk', 30), ('jnk', 10), ('ffk', 1)], activation="linear")

#model.compile(optimizer="adam", loss="mse", metrics=["accuracy", "mae"])
#model.fit(X, Y, epochs=100)

"""
preds = model.predict(X)
plt.plot(preds, 'b')
plt.plot(Y, 'y')
plt.show()
"""